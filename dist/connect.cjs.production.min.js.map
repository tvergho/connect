{"version":3,"file":"connect.cjs.production.min.js","sources":["../src/utils.ts","../src/auth.ts","../src/types/transactions.ts","../src/transactions/index.ts","../src/ui.ts"],"sourcesContent":["export function getStacksProvider() {\n  return window.StacksProvider || window.BlockstackProvider;\n}\n\nexport function isStacksWalletInstalled() {\n  return !!getStacksProvider();\n}\n","import { AppConfig, UserSession } from '@stacks/auth';\nimport { decodeToken } from 'jsontokens';\nimport type { AuthOptions, AuthResponsePayload } from './types';\n\nimport { getStacksProvider } from './utils';\n\nexport const defaultAuthURL = 'https://app.blockstack.org';\n\nconst version = __VERSION__;\n\nif (typeof window !== 'undefined') {\n  window.__CONNECT_VERSION__ = version;\n}\n\nexport const isMobile = () => {\n  const ua = navigator.userAgent;\n  if (/android/i.test(ua)) {\n    return true;\n  }\n  if (/iPad|iPhone|iPod/.test(ua)) {\n    return true;\n  }\n  return /windows phone/i.test(ua);\n};\n\n/**\n * mobile should not use a 'popup' type of window.\n */\nexport const shouldUsePopup = () => {\n  return !isMobile();\n};\n\nexport const getOrCreateUserSession = (userSession?: UserSession): UserSession => {\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport const authenticate = async (authOptions: AuthOptions) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Unable to authenticate without Hiro Wallet extension');\n  }\n\n  const {\n    redirectTo = '/',\n    manifestPath,\n    onFinish,\n    onCancel,\n    sendToSignIn = false,\n    userSession: _userSession,\n    appDetails,\n  } = authOptions;\n  const userSession = getOrCreateUserSession(_userSession);\n  if (userSession.isUserSignedIn()) {\n    userSession.signUserOut();\n  }\n  const transitKey = userSession.generateAndStoreTransitKey();\n  const authRequest = userSession.makeAuthRequest(\n    transitKey,\n    `${document.location.origin}${redirectTo}`,\n    `${document.location.origin}${manifestPath}`,\n    userSession.appConfig.scopes,\n    undefined,\n    undefined,\n    {\n      sendToSignIn,\n      appDetails,\n      connectVersion: version,\n    }\n  );\n\n  try {\n    const authResponse = await provider.authenticationRequest(authRequest);\n    await userSession.handlePendingSignIn(authResponse);\n    const token = decodeToken(authResponse);\n    const payload = token?.payload;\n    const authResponsePayload = payload as unknown as AuthResponsePayload;\n    onFinish?.({\n      authResponse,\n      authResponsePayload,\n      userSession,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during auth request', error);\n    onCancel?.();\n  }\n};\n\nexport const getUserData = async (userSession?: UserSession) => {\n  userSession = getOrCreateUserSession(userSession);\n  if (userSession.isUserSignedIn()) {\n    return userSession.loadUserData();\n  }\n  if (userSession.isSignInPending()) {\n    return userSession.handlePendingSignIn();\n  }\n  return null;\n};\n","import { UserSession } from '@stacks/auth';\nimport type { AuthOptions } from '../types/auth';\nimport {\n  PostConditionMode,\n  PostCondition,\n  AnchorMode,\n  ClarityValue,\n  StacksTransaction,\n} from '@stacks/transactions';\nimport { StacksNetwork } from '@stacks/network';\nimport BN from 'bn.js';\n\nexport interface TxBase {\n  appDetails?: AuthOptions['appDetails'];\n  postConditionMode?: PostConditionMode;\n  postConditions?: (string | PostCondition)[];\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  attachment?: string;\n  fee?: number | string;\n  /**\n   * Provide the Hiro Wallet with a suggested account to sign this transaction with.\n   * This is set by default if a `userSession` option is provided.\n   */\n  stxAddress?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  senderKey?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  nonce?: number;\n}\n\nexport interface SponsoredFinishedTxPayload {\n  txRaw: string;\n}\n\nexport interface SponsoredFinishedTxData extends SponsoredFinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport interface FinishedTxPayload extends SponsoredFinishedTxPayload {\n  txId: string;\n}\n\nexport interface FinishedTxData extends FinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport enum TransactionTypes {\n  ContractCall = 'contract_call',\n  ContractDeploy = 'smart_contract',\n  STXTransfer = 'token_transfer',\n}\n\n/**\n * Contract Call\n */\n\nexport enum ContractCallArgumentType {\n  BUFFER = 'buffer',\n  UINT = 'uint',\n  INT = 'int',\n  PRINCIPAL = 'principal',\n  BOOL = 'bool',\n}\n\nexport interface ContractCallBase extends TxBase {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: (string | ClarityValue)[];\n}\n\nexport interface OptionsBase {\n  /**\n   * @deprecated Authentication is no longer supported through a hosted\n   * version. Users must install an extension.\n   */\n  authOrigin?: string;\n  userSession?: UserSession;\n}\n\nexport type SponsoredFinished = (data: SponsoredFinishedTxData) => void;\nexport type Finished = (data: FinishedTxData) => void;\nexport type Canceled = () => void;\n\nexport interface SponsoredOptionsBase extends TxBase, OptionsBase {\n  sponsored: true;\n  onFinish?: SponsoredFinished;\n  onCancel?: Canceled;\n}\n\nexport interface RegularOptionsBase extends TxBase, OptionsBase {\n  sponsored?: false;\n  onFinish?: Finished;\n  onCancel?: Canceled;\n}\n\nexport type ContractCallRegularOptions = ContractCallBase & RegularOptionsBase;\nexport type ContractCallSponsoredOptions = ContractCallBase & SponsoredOptionsBase;\nexport type ContractCallOptions = ContractCallRegularOptions | ContractCallSponsoredOptions;\n\nexport interface ContractCallArgument {\n  type: ContractCallArgumentType;\n  value: string;\n}\n\nexport interface ContractCallPayload extends ContractCallBase {\n  txType: TransactionTypes.ContractCall;\n  publicKey: string;\n  functionArgs: string[];\n  sponsored?: boolean;\n}\n\n/**\n * Contract Deploy\n */\nexport interface ContractDeployBase extends TxBase {\n  contractName: string;\n  codeBody: string;\n}\n\nexport type ContractDeployRegularOptions = ContractDeployBase & RegularOptionsBase;\nexport type ContractDeploySponsoredOptions = ContractDeployBase & SponsoredOptionsBase;\nexport type ContractDeployOptions = ContractDeployRegularOptions | ContractDeploySponsoredOptions;\n\nexport interface ContractDeployPayload extends ContractDeployBase {\n  publicKey: string;\n  txType: TransactionTypes.ContractDeploy;\n  sponsored?: boolean;\n}\n\n/**\n * STX Transfer\n */\n\nexport interface STXTransferBase extends TxBase {\n  recipient: string;\n  amount: BN | string;\n  memo?: string;\n}\n\nexport type STXTransferRegularOptions = STXTransferBase & RegularOptionsBase;\nexport type STXTransferSponsoredOptions = STXTransferBase & SponsoredOptionsBase;\nexport type STXTransferOptions = STXTransferRegularOptions | STXTransferSponsoredOptions;\n\nexport interface STXTransferPayload extends STXTransferBase {\n  publicKey: string;\n  txType: TransactionTypes.STXTransfer;\n  amount: string;\n  sponsored?: boolean;\n}\n\n/**\n * Transaction Popup\n */\n\nexport type TransactionOptions = ContractCallOptions | ContractDeployOptions | STXTransferOptions;\nexport type TransactionPayload = ContractCallPayload | ContractDeployPayload | STXTransferPayload;\n\nexport interface TransactionPopup {\n  token: string;\n  options: TransactionOptions;\n}\n","import { UserSession, AppConfig } from '@stacks/auth';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport {\n  ContractCallOptions,\n  ContractCallPayload,\n  ContractDeployOptions,\n  ContractDeployPayload,\n  TransactionPopup,\n  TransactionOptions,\n  STXTransferOptions,\n  STXTransferPayload,\n  TransactionPayload,\n  TransactionTypes,\n  STXTransferSponsoredOptions,\n  STXTransferRegularOptions,\n  ContractDeployRegularOptions,\n  ContractDeploySponsoredOptions,\n  ContractCallRegularOptions,\n  ContractCallSponsoredOptions,\n  SponsoredFinishedTxPayload,\n  FinishedTxPayload,\n} from '../types/transactions';\nimport {\n  serializeCV,\n  ChainID,\n  deserializeTransaction,\n  BufferReader,\n  serializePostCondition,\n  PostCondition,\n} from '@stacks/transactions';\nimport { getStacksProvider } from '../utils';\nimport { StacksTestnet } from '@stacks/network';\n\nconst getUserSession = (_userSession?: UserSession) => {\n  let userSession = _userSession;\n\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nconst getKeys = (_userSession?: UserSession) => {\n  const userSession = getUserSession(_userSession);\n  const privateKey = userSession.loadUserData().appPrivateKey;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  return { privateKey, publicKey };\n};\n\nfunction getStxAddress(options: TransactionOptions) {\n  const { stxAddress, userSession, network } = options;\n\n  if (stxAddress) return stxAddress;\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction getDefaults(options: TransactionOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: TransactionOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nconst signPayload = async (payload: TransactionPayload, privateKey: string) => {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = (postConditions as PostCondition[]).map(pc =>\n      serializePostCondition(pc).toString('hex')\n    );\n  }\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.signAsync({\n    ...payload,\n    postConditions,\n  } as any);\n};\n\nconst openTransactionPopup = async ({ token, options }: TransactionPopup) => {\n  const provider = getStacksProvider();\n  if (!provider) {\n    throw new Error('Hiro Wallet not installed.');\n  }\n\n  try {\n    const txResponse = await provider.transactionRequest(token);\n    const { txRaw } = txResponse;\n    const txBuffer = Buffer.from(txRaw.replace(/^0x/, ''), 'hex');\n    const stacksTransaction = deserializeTransaction(new BufferReader(txBuffer));\n\n    if ('sponsored' in options && options.sponsored) {\n      options.onFinish?.({\n        ...(txResponse as SponsoredFinishedTxPayload),\n        stacksTransaction,\n      });\n      return;\n    }\n    options.onFinish?.({\n      ...(txResponse as FinishedTxPayload),\n      stacksTransaction,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during transaction request', error);\n    options.onCancel?.();\n  }\n};\n\nexport const makeContractCallToken = async (options: ContractCallOptions) => {\n  const { functionArgs, appDetails, userSession, ..._options } = options;\n  const { privateKey, publicKey } = getKeys(userSession);\n\n  const args: string[] = functionArgs.map(arg => {\n    if (typeof arg === 'string') {\n      return arg;\n    }\n    return serializeCV(arg).toString('hex');\n  });\n\n  const payload: ContractCallPayload = {\n    ..._options,\n    functionArgs: args,\n    txType: TransactionTypes.ContractCall,\n    publicKey,\n  };\n\n  if (appDetails) {\n    payload.appDetails = appDetails;\n  }\n\n  return signPayload(payload, privateKey);\n};\n\nexport const makeContractDeployToken = async (options: ContractDeployOptions) => {\n  const { appDetails, userSession, ..._options } = options;\n  const { privateKey, publicKey } = getKeys(userSession);\n\n  const payload: ContractDeployPayload = {\n    ..._options,\n    publicKey,\n    txType: TransactionTypes.ContractDeploy,\n  };\n\n  if (appDetails) {\n    payload.appDetails = appDetails;\n  }\n\n  return signPayload(payload, privateKey);\n};\n\nexport const makeSTXTransferToken = async (options: STXTransferOptions) => {\n  const { amount, appDetails, userSession, ..._options } = options;\n  const { privateKey, publicKey } = getKeys(userSession);\n\n  const payload: STXTransferPayload = {\n    ..._options,\n    amount: amount.toString(10),\n    publicKey,\n    txType: TransactionTypes.STXTransfer,\n  };\n\n  if (appDetails) {\n    payload.appDetails = appDetails;\n  }\n\n  return signPayload(payload, privateKey);\n};\n\nasync function generateTokenAndOpenPopup<T extends TransactionOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>\n) {\n  const token = await makeTokenFn({\n    ...getDefaults(options),\n    ...options,\n  } as T);\n  return openTransactionPopup({ token, options });\n}\n\nexport function openContractCall(options: ContractCallRegularOptions): Promise<void>;\nexport function openContractCall(options: ContractCallSponsoredOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions): Promise<void>;\nexport function openContractCall(options: ContractCallOptions) {\n  return generateTokenAndOpenPopup(options, makeContractCallToken);\n}\n\nexport function openContractDeploy(options: ContractDeployRegularOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeploySponsoredOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions): Promise<void>;\nexport function openContractDeploy(options: ContractDeployOptions) {\n  return generateTokenAndOpenPopup(options, makeContractDeployToken);\n}\n\nexport function openSTXTransfer(options: STXTransferRegularOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferSponsoredOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions): Promise<void>;\nexport function openSTXTransfer(options: STXTransferOptions) {\n  return generateTokenAndOpenPopup(options, makeSTXTransferToken);\n}\n","import { authenticate } from './auth';\nimport type { AuthOptions } from './types/auth';\nimport { defineCustomElements } from '@stacks/connect-ui/loader';\nimport { getStacksProvider } from './utils';\n\nexport const showConnect = (authOptions: AuthOptions) => {\n  if (getStacksProvider()) {\n    void authenticate(authOptions);\n    return;\n  }\n  if (typeof window !== undefined) {\n    void defineCustomElements(window);\n    const element = document.createElement('connect-modal');\n    element.authOptions = authOptions;\n    document.body.appendChild(element);\n    const handleEsc = (ev: KeyboardEvent) => {\n      if (ev.key === 'Escape') {\n        document.removeEventListener('keydown', handleEsc);\n        element.remove();\n      }\n    };\n    document.addEventListener('keydown', handleEsc);\n  }\n};\n\n/**\n * @deprecated Use the renamed `showConnect` method\n */\nexport const showBlockstackConnect = (authOptions: AuthOptions) => showConnect(authOptions);\n"],"names":["window","StacksProvider","BlockstackProvider","__CONNECT_VERSION__","__VERSION__","TransactionTypes2","ContractCallArgumentType2","isMobile","ua","navigator","userAgent","test","getOrCreateUserSession","userSession","appConfig","AppConfig","document","location","href","UserSession","authenticate","authOptions","provider","getStacksProvider","Error","redirectTo","manifestPath","onFinish","onCancel","sendToSignIn","appDetails","isUserSignedIn","signUserOut","transitKey","generateAndStoreTransitKey","authRequest","makeAuthRequest","origin","scopes","connectVersion","authenticationRequest","authResponse","handlePendingSignIn","token","decodeToken","authResponsePayload","payload","error","getUserData","loadUserData","isSignInPending","TransactionTypes","ContractCallArgumentType","getUserSession","_userSession","getKeys","privateKey","appPrivateKey","publicKey","SECP256K1Client","derivePublicKey","options","stxAddress","network","stxAddresses","profile","_userSession$loadUser","chainIdToKey","ChainID","Mainnet","Testnet","chainId","defaults","StacksTestnet","getStxAddress","signPayload","postConditions","map","serializePostCondition","pc","toString","tokenSigner","TokenSigner","signAsync","openTransactionPopup","transactionRequest","txResponse","txBuffer","Buffer","from","txRaw","replace","stacksTransaction","deserializeTransaction","BufferReader","sponsored","makeContractCallToken","functionArgs","_options","args","arg","serializeCV","txType","ContractCall","makeContractDeployToken","ContractDeploy","makeSTXTransferToken","amount","STXTransfer","makeTokenFn","getDefaults","showConnect","defineCustomElements","element","createElement","body","appendChild","addEventListener","handleEsc","ev","key","removeEventListener","remove","generateTokenAndOpenPopup"],"mappings":"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"}